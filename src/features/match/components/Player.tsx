/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 player.glb -TtjM 
Command args: --types --transform --keepmeshes --keepmaterials
Files: player.glb [27.72MB] > C:\Users\immam\OneDrive\Documents\blender\character\player-transformed.glb [645.56KB] (98%)
*/
import { Billboard, Text, useAnimations, useGLTF } from "@react-three/drei";
import { RootState, useGraph } from "@react-three/fiber";
import React, { useEffect, useLayoutEffect, useMemo, useRef } from "react";
import {
  CanvasTexture,
  Group,
  MeshPhysicalMaterial,
  RepeatWrapping,
} from "three";
import { SkeletonUtils } from "three-stdlib";
import { PoseRecord } from "../animations/player/PoseAction.model";
import {
  PlayerAnimationsConfig,
  setupPlayerAnimations,
} from "../animations/player/setupPlayer";
import { secondsToStep } from "../animations/positions.utils";
import { MatchPlayer, TeamColors } from "../MatchData.model";
import { GLTFResult } from "./playerGltf.model";
import { useMatchDirector } from "./useMatchDirector";
import { useMaterialClone } from "./useMaterialClone";
import { useAppZuStore } from "/app/app.zu.store";

const MODEL_URL = "models/player-transformed.glb";

export type PlayerProps = {
  // bodyColor: ColorRepresentation;
  colors: TeamColors;
  teamIdx: 0 | 1;
  playerIdx: number;
  dbgLabelVisible: boolean;
  // movements?: PlayerMovement;
  player: MatchPlayer;
};

export function Player({
  colors,
  teamIdx,
  playerIdx,
  dbgLabelVisible,
  // movements,
  player,
  ...props
}: PlayerProps & JSX.IntrinsicElements["group"]) {
  const playerId = useMemo(
    () => ({ teamIdx, playerIdx }),
    [teamIdx, playerIdx]
  );

  // console.log("player movements", player);

  const playerRef = React.useRef<Group>(null);
  const groupRef = React.useRef<Group>(new Group());

  const { scene, animations } = useGLTF(MODEL_URL);
  const poseAnimations = useAnimations(animations, playerRef);

  const sceneClone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(sceneClone) as GLTFResult;

  const bodyMaterial = materials.Ch38_body;
  // TODO: body color is to dark;
  // const bodyMaterial = useMaterialClone(materials.Ch38_body, bodyColor);
  const shortsMaterial = useMaterialClone(materials.Ch38_body, colors.shorts);
  const socksMaterial = useMaterialClone(materials.Ch38_body, colors.shirt);

  const matchPaused = useAppZuStore((state) => state.mediaPlayer.paused);
  const startTime = useAppZuStore((state) => state.mediaPlayer.startTime);
  const playbackSpeed = useAppZuStore(
    (state) => state.mediaPlayer.playbackSpeed
  );

  const squadPlayer = useAppZuStore(
    (state) => state.teams.teamsArray[teamIdx].squadPlayers[playerIdx]
  );
  const isDebug = useAppZuStore(({ debug }) => debug.isDebug);

  const config = useRef<PlayerAnimationsConfig>();

  useEffect(() => {
    if (playerRef.current && !config.current && player.movements) {
      const result = setupPlayerAnimations(
        playerId,
        playerRef.current,
        poseAnimations.actions,
        player.movements
      );
      config.current = result;
      result.playerPoses.forceIdle();
      result.positionAction.play();
      result.rotateAction.play();
    }
  }, [poseAnimations.actions, playerId, player]);

  useEffect(() => {
    if (config.current) {
      if (!config.current.mixer.timeScale) {
        throw new Error("Player config.mixer.timeScale == 0");
      }
      config.current.positionAction.paused = false;
      config.current.rotateAction.paused = false;
      config.current.mixer.setTime(startTime / config.current.mixer.timeScale);
      config.current.playerPoses.forceUpdatePose = true;
    }
  }, [startTime]);

  useEffect(() => {
    if (config.current) {
      config.current.mixer.timeScale = playbackSpeed;
      config.current.positionAction.paused = false;
      config.current.rotateAction.paused = false;
    }
  }, [playbackSpeed]);

  const lastRawPoseRef = useRef<string>();

  useEffect(() => {
    if (poseAnimations.mixer)
      poseAnimations.mixer.timeScale = matchPaused ? 0 : playbackSpeed;
  }, [poseAnimations.mixer, playbackSpeed, matchPaused]);

  const onFrameUpdate = useMemo(() => {
    return (_: RootState, delta: number) => {
      if (!config.current) return;
      const pose = config.current.playerPoses.updatePose(delta);
      if (pose) {
        labelVisible(pose.distanceToBall < 2);
      }
      updateDbgLabel(config.current, pose);
    };

    function updateDbgLabel(
      config: PlayerAnimationsConfig,
      pose: PoseRecord | undefined
    ) {
      if (dbgLabelRef.current && dbgLabelVisible) {
        const step = secondsToStep(config.mixer.time);
        if (pose?.rawPose) {
          lastRawPoseRef.current = `(${step}: ${pose.rawPose})`;
        }
        dbgLabelRef.current.text =
          (config.mixer.time > 0 &&
            `(step: ${step}, time: ${config.mixer.time.toFixed(1)})\n`) +
          `${teamIdx === 0 ? "Home" : "Away"} ${playerIdx + 1} ${
            pose?.type ?? ""
          } / ${lastRawPoseRef.current ?? ""} / ${pose?.rawPose ?? ""}`;
      }
    }
  }, [config, teamIdx, playerIdx, dbgLabelVisible]);

  function labelVisible(visible = false) {
    const isVisible =
      playerSelectedRef.current || playerHoverRef.current || visible;
    if (labelRef.current) {
      labelRef.current.visible = isVisible;
    }
    // if (labelHtmlRef.current) {
    //   labelHtmlRef.current.style.display = isVisible ? "block" : "none";
    // }
  }

  useMatchDirector(config.current?.mixer, false, onFrameUpdate);

  const labelRef = useRef<Group>(null);
  // const labelHtmlRef = useRef<HTMLDivElement>(null);
  const playerSelectedRef = useRef(false);
  const playerHoverRef = useRef(false);
  const dbgLabelRef = useRef<{ text: string }>(null);

  const canvasTextureRef = useRef<CanvasTexture>(null);
  const canvasRef = useRef(document.createElement("canvas"));
  const context = useRef(canvasRef.current.getContext("2d"));
  const canvaMaterialRef = useRef<MeshPhysicalMaterial>(null);
  canvasRef.current.width = 512;
  canvasRef.current.height = 512;

  // shirt material
  useLayoutEffect(() => {
    if (!materials.Shirt_Material?.map) return;
    canvasRef.current.width = materials.Shirt_Material.map.image.width;
    canvasRef.current.height = materials.Shirt_Material.map.image.height;
    // if (canvasTextureRef.current) canvasTextureRef.current.needsUpdate = true;

    if (!materials.Shirt_Material?.map) return;
    const ctx = context.current;
    if (!ctx) return;

    // ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
    ctx.drawImage(materials.Shirt_Material.map.image, 0.0, 0.0);
    ctx.fillStyle = colors.shirt.toString() + "f0";
    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);

    // number
    ctx.font = "bold 100px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = colors.text.toString();
    ctx.fillText(player.shirtNumber, 120, 350);
    // name
    ctx.font = "normal 20px Arial";
    ctx.fillText(
      player.name.split(" ").reverse()[0].slice(0, 20),
      120,
      280,
      150
    );
    if (canvasTextureRef.current) canvasTextureRef.current.needsUpdate = true;
  }, [materials.Shirt_Material, colors, player]);

  return (
    <group
      name={`Player`}
      ref={playerRef}
      {...props}
      dispose={null}
      visible={!!config}
      raycast={() => null}
    >
      {isDebug && (
        <>
          <Billboard>
            <Text
              color="#505050"
              anchorX="center"
              anchorY="bottom"
              textAlign="center"
              position={[0, 2.3, 0]}
              fontSize={0.3}
              ref={dbgLabelRef}
              visible={dbgLabelVisible}
            >
              {" "}
            </Text>
          </Billboard>
        </>
      )}

      <Billboard visible={false} ref={labelRef}>
        <Text
          color="black"
          anchorX="center"
          anchorY="bottom"
          textAlign="center"
          position={[0, 2, 0]}
          fontSize={0.3}
        >
          {/* ${teamIdx ? "Away" : "Home"}\n */}
          {`${squadPlayer.shirtNumber}. ${squadPlayer.name}`}
        </Text>
      </Billboard>

      {/* <Html
        style={{display: "none"}}
        className="player-label"
        wrapperClass="player-label-wrapper"
        ref={labelHtmlRef}
        position={[0, 2, 0]}
        center
      >{`${squadPlayer.shirtNumber}. ${squadPlayer.name}`}</Html> 
      */}
      <mesh
        // ref={meshHelper}
        onPointerEnter={(e) => {
          e.stopPropagation();
          playerHoverRef.current = true;
          labelVisible();
        }}
        onPointerLeave={(e) => {
          e.stopPropagation();
          playerHoverRef.current = false;
          labelVisible();
        }}
        onClick={(e) => {
          e.stopPropagation();
          playerSelectedRef.current = !playerSelectedRef.current;
          labelVisible(playerSelectedRef.current);
        }}
        visible={false}
        position-y={0.9}
      >
        {/* <bufferGeometry attach="geometry" /> */}
        <boxGeometry args={[0.5, 1.7, 0.5]} />
        <meshBasicMaterial
          wireframe={true}
          transparent={true}
          opacity={0.5}
          depthWrite={false}
        />
      </mesh>

      <group
        name={`Player-${teamIdx}-${playerIdx}`}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.01}
        dispose={null}
        ref={groupRef}
        raycast={() => null}
      >
        <primitive object={nodes.mixamorig5Hips} />
        <skinnedMesh
          name="Ch38_Body"
          geometry={nodes.Ch38_Body.geometry}
          material={bodyMaterial}
          skeleton={nodes.Ch38_Body.skeleton}
          raycast={() => null}
        ></skinnedMesh>
        <skinnedMesh
          name="Ch38_Shirt"
          geometry={nodes.Ch38_Shirt.geometry}
          // material={shirtMaterial}
          skeleton={nodes.Ch38_Shirt.skeleton}
          raycast={() => null}
        >
          <meshPhysicalMaterial ref={canvaMaterialRef} side={2}>
            <canvasTexture
              ref={canvasTextureRef}
              attach="map"
              image={canvasRef.current}
              wrapS={RepeatWrapping}
              wrapT={RepeatWrapping}
              flipY={false}
            />
          </meshPhysicalMaterial>
        </skinnedMesh>

        <skinnedMesh
          name="Ch38_Shorts"
          geometry={nodes.Ch38_Shorts.geometry}
          material={shortsMaterial}
          skeleton={nodes.Ch38_Shorts.skeleton}
          raycast={() => null}
          castShadow
        />
        <skinnedMesh
          name="Ch38_Socks"
          geometry={nodes.Ch38_Socks.geometry}
          material={socksMaterial}
          skeleton={nodes.Ch38_Socks.skeleton}
          raycast={() => null}
        />
        <skinnedMesh
          name="Ch38_Shoes"
          geometry={nodes.Ch38_Shoes.geometry}
          material={bodyMaterial}
          skeleton={nodes.Ch38_Shoes.skeleton}
          raycast={() => null}
        />
      </group>
    </group>
  );
}

useGLTF.preload(MODEL_URL);
